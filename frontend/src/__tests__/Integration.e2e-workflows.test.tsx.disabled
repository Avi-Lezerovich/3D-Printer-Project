import React from 'react';
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, waitFor, within, act } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { MemoryRouter } from 'react-router-dom';
import { SocketProvider } from '../../core/realtime/SocketProvider';

// Mock the complete application structure for integration testing
const mockSocket = {
  on: vi.fn(),
  off: vi.fn(),
  emit: vi.fn(),
  disconnect: vi.fn(),
  connect: vi.fn()
};

vi.mock('socket.io-client', () => ({
  io: () => mockSocket
}));

// Mock app store with realistic state management
const createMockStore = () => {
  let state = {
    jobs: [] as Array<{ id: string; name: string; status: string; progress: number }>,
    projects: [] as Array<{ id: string; name: string; tasks: any[] }>,
    user: null as any,
    printerStatus: 'idle' as string,
    temperature: { hotend: 20, bed: 20 }
  };

  const listeners: Function[] = [];

  return {
    getState: () => state,
    setState: (newState: any) => {
      state = { ...state, ...newState };
      listeners.forEach(fn => fn(state));
    },
    subscribe: (fn: Function) => {
      listeners.push(fn);
      return () => {
        const index = listeners.indexOf(fn);
        if (index > -1) listeners.splice(index, 1);
      };
    },
    // Action methods
    addJob: vi.fn((job) => {
      state.jobs = [...state.jobs, job];
      listeners.forEach(fn => fn(state));
    }),
    updateJob: vi.fn((id, updates) => {
      state.jobs = state.jobs.map(job => 
        job.id === id ? { ...job, ...updates } : job
      );
      listeners.forEach(fn => fn(state));
    }),
    removeJob: vi.fn((id) => {
      state.jobs = state.jobs.filter(job => job.id !== id);
      listeners.forEach(fn => fn(state));
    }),
    updatePrinterStatus: vi.fn((status) => {
      state.printerStatus = status;
      listeners.forEach(fn => fn(state));
    }),
    updateTemperature: vi.fn((temp) => {
      state.temperature = temp;
      listeners.forEach(fn => fn(state));
    })
  };
};

let mockStore = createMockStore();

vi.mock('../../shared/store', () => ({
  useAppStore: (selector?: Function) => {
    const state = mockStore.getState();
    return selector ? selector(state) : mockStore;
  }
}));

// Mock API calls
const mockApiCalls = {
  uploadFile: vi.fn(),
  createProject: vi.fn(),
  addTask: vi.fn(),
  startPrint: vi.fn(),
  stopPrint: vi.fn(),
  pausePrint: vi.fn()
};

vi.mock('../../services/api', () => ({
  apiFetch: vi.fn((url, options) => {
    if (url.includes('/upload')) return mockApiCalls.uploadFile(options);
    if (url.includes('/projects') && options?.method === 'POST') return mockApiCalls.createProject(options);
    if (url.includes('/tasks') && options?.method === 'POST') return mockApiCalls.addTask(options);
    if (url.includes('/print/start')) return mockApiCalls.startPrint(options);
    if (url.includes('/print/stop')) return mockApiCalls.stopPrint(options);
    if (url.includes('/print/pause')) return mockApiCalls.pausePrint(options);
    return Promise.resolve({ data: {} });
  })
}));

// Complete 3D Printing Application Mock
const PrintingApp = () => {
  const [currentView, setCurrentView] = React.useState('upload');
  const [selectedProject, setSelectedProject] = React.useState<string | null>(null);

  return (
    <div className="printing-app">
      <nav aria-label="Main navigation">
        <button 
          onClick={() => setCurrentView('upload')}
          aria-pressed={currentView === 'upload'}
        >
          File Upload
        </button>
        <button 
          onClick={() => setCurrentView('projects')}
          aria-pressed={currentView === 'projects'}
        >
          Projects
        </button>
        <button 
          onClick={() => setCurrentView('control')}
          aria-pressed={currentView === 'control'}
        >
          Printer Control
        </button>
        <button 
          onClick={() => setCurrentView('monitor')}
          aria-pressed={currentView === 'monitor'}
        >
          Live Monitor
        </button>
      </nav>

      <main>
        {currentView === 'upload' && <FileUploadView />}
        {currentView === 'projects' && (
          <ProjectsView 
            onSelectProject={setSelectedProject}
            selectedProject={selectedProject}
          />
        )}
        {currentView === 'control' && <PrinterControlView />}
        {currentView === 'monitor' && <LiveMonitorView />}
      </main>
    </div>
  );
};

const FileUploadView = () => {
  const [files, setFiles] = React.useState<File[]>([]);
  const [uploading, setUploading] = React.useState(false);

  const handleFileUpload = async (selectedFiles: File[]) => {
    setFiles(prev => [...prev, ...selectedFiles]);
    setUploading(true);

    try {
      for (const file of selectedFiles) {
        await mockApiCalls.uploadFile({ body: file });
        mockStore.addJob({
          id: `job-${Date.now()}-${Math.random()}`,
          name: file.name,
          status: 'queued',
          progress: 0
        });
      }
    } finally {
      setUploading(false);
    }
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    const droppedFiles = Array.from(e.dataTransfer.files);
    handleFileUpload(droppedFiles);
  };

  return (
    <section aria-labelledby="upload-heading">
      <h1 id="upload-heading">Upload 3D Models</h1>
      
      <div 
        role="button"
        tabIndex={0}
        onDrop={handleDrop}
        onDragOver={e => e.preventDefault()}
        className="drop-zone"
        aria-label="Drop 3D model files here or click to browse"
      >
        <input
          type="file"
          multiple
          accept=".gcode,.stl"
          onChange={e => e.target.files && handleFileUpload(Array.from(e.target.files))}
          style={{ display: 'none' }}
          id="file-input"
        />
        <label htmlFor="file-input">
          {uploading ? 'Uploading...' : 'Drop files here or click to browse'}
        </label>
      </div>

      {files.length > 0 && (
        <div>
          <h2>Uploaded Files ({files.length})</h2>
          <ul>
            {files.map((file, index) => (
              <li key={index}>
                <span>{file.name}</span>
                <span>({(file.size / 1024).toFixed(1)} KB)</span>
              </li>
            ))}
          </ul>
        </div>
      )}
    </section>
  );
};

const ProjectsView = ({ 
  onSelectProject, 
  selectedProject 
}: {
  onSelectProject: (id: string) => void;
  selectedProject: string | null;
}) => {
  const projects = mockStore.getState().projects;

  const createNewProject = async () => {
    const projectName = prompt('Enter project name:');
    if (projectName) {
      await mockApiCalls.createProject({ name: projectName });
      // Update store with new project
    }
  };

  return (
    <section aria-labelledby="projects-heading">
      <h1 id="projects-heading">Projects</h1>
      
      <button onClick={createNewProject}>
        Create New Project
      </button>

      <div className="projects-grid">
        {projects.map(project => (
          <div 
            key={project.id}
            className={`project-card ${selectedProject === project.id ? 'selected' : ''}`}
            onClick={() => onSelectProject(project.id)}
            role="button"
            tabIndex={0}
            aria-pressed={selectedProject === project.id}
          >
            <h3>{project.name}</h3>
            <p>{project.tasks.length} tasks</p>
          </div>
        ))}
      </div>

      {selectedProject && <ProjectDetails projectId={selectedProject} />}
    </section>
  );
};

const ProjectDetails = ({ projectId }: { projectId: string }) => {
  const [newTaskName, setNewTaskName] = React.useState('');

  const addTask = async () => {
    if (newTaskName.trim()) {
      await mockApiCalls.addTask({ 
        projectId, 
        name: newTaskName,
        status: 'todo'
      });
      setNewTaskName('');
    }
  };

  return (
    <div className="project-details">
      <h3>Project Details</h3>
      
      <div className="add-task">
        <input
          type="text"
          value={newTaskName}
          onChange={e => setNewTaskName(e.target.value)}
          placeholder="New task name"
          onKeyDown={e => e.key === 'Enter' && addTask()}
        />
        <button onClick={addTask} disabled={!newTaskName.trim()}>
          Add Task
        </button>
      </div>
    </div>
  );
};

const PrinterControlView = () => {
  const printerStatus = mockStore.getState().printerStatus;
  const jobs = mockStore.getState().jobs;
  const [selectedJob, setSelectedJob] = React.useState<string | null>(null);

  const startPrint = async () => {
    if (selectedJob) {
      await mockApiCalls.startPrint({ jobId: selectedJob });
      mockStore.updatePrinterStatus('printing');
      mockStore.updateJob(selectedJob, { status: 'printing' });
    }
  };

  const pausePrint = async () => {
    await mockApiCalls.pausePrint({});
    mockStore.updatePrinterStatus('paused');
  };

  const stopPrint = async () => {
    if (window.confirm('Are you sure you want to stop the current print?')) {
      await mockApiCalls.stopPrint({});
      mockStore.updatePrinterStatus('idle');
    }
  };

  return (
    <section aria-labelledby="control-heading">
      <h1 id="control-heading">Printer Control</h1>
      
      <div className="status-display">
        <h2>Current Status</h2>
        <div className={`status-badge ${printerStatus}`}>
          {printerStatus.charAt(0).toUpperCase() + printerStatus.slice(1)}
        </div>
      </div>

      <div className="job-queue">
        <h2>Print Queue</h2>
        {jobs.length === 0 ? (
          <p>No jobs in queue. Upload files first.</p>
        ) : (
          <ul>
            {jobs.map(job => (
              <li 
                key={job.id}
                className={selectedJob === job.id ? 'selected' : ''}
              >
                <input
                  type="radio"
                  name="selected-job"
                  id={`job-${job.id}`}
                  value={job.id}
                  checked={selectedJob === job.id}
                  onChange={() => setSelectedJob(job.id)}
                />
                <label htmlFor={`job-${job.id}`}>
                  {job.name} - {job.status} ({job.progress}%)
                </label>
              </li>
            ))}
          </ul>
        )}
      </div>

      <div className="control-buttons">
        <button 
          onClick={startPrint}
          disabled={!selectedJob || printerStatus === 'printing'}
        >
          Start Print
        </button>
        <button 
          onClick={pausePrint}
          disabled={printerStatus !== 'printing'}
        >
          Pause
        </button>
        <button 
          onClick={stopPrint}
          disabled={printerStatus === 'idle'}
          className="danger"
        >
          Stop Print
        </button>
      </div>
    </section>
  );
};

const LiveMonitorView = () => {
  const printerStatus = mockStore.getState().printerStatus;
  const temperature = mockStore.getState().temperature;
  const [progress, setProgress] = React.useState(0);

  React.useEffect(() => {
    if (printerStatus === 'printing') {
      const interval = setInterval(() => {
        setProgress(prev => {
          const newProgress = Math.min(prev + Math.random() * 5, 100);
          if (newProgress === 100) {
            mockStore.updatePrinterStatus('completed');
          }
          return newProgress;
        });
      }, 1000);

      return () => clearInterval(interval);
    }
  }, [printerStatus]);

  React.useEffect(() => {
    // Simulate real-time temperature updates
    if (printerStatus === 'printing') {
      const interval = setInterval(() => {
        mockStore.updateTemperature({
          hotend: 200 + Math.random() * 20,
          bed: 60 + Math.random() * 10
        });
      }, 2000);

      return () => clearInterval(interval);
    }
  }, [printerStatus]);

  return (
    <section aria-labelledby="monitor-heading">
      <h1 id="monitor-heading">Live Monitor</h1>
      
      <div className="monitor-grid">
        <div className="progress-display">
          <h2>Print Progress</h2>
          <div 
            role="progressbar"
            aria-valuenow={progress}
            aria-valuemin={0}
            aria-valuemax={100}
            aria-label={`Print progress: ${progress.toFixed(1)}%`}
          >
            <div className="progress-bar">
              <div 
                className="progress-fill"
                style={{ width: `${progress}%` }}
              />
            </div>
            <span>{progress.toFixed(1)}%</span>
          </div>
        </div>

        <div className="temperature-display">
          <h2>Temperature</h2>
          <div>
            <span>Hotend: {temperature.hotend.toFixed(1)}°C</span>
          </div>
          <div>
            <span>Bed: {temperature.bed.toFixed(1)}°C</span>
          </div>
        </div>

        <div className="webcam-feed">
          <h2>Live Camera</h2>
          <div className="webcam-placeholder">
            {printerStatus === 'printing' ? 'Camera feed active' : 'Camera offline'}
          </div>
        </div>
      </div>

      <div role="log" aria-live="polite" aria-label="Print status updates">
        {printerStatus === 'printing' && progress > 0 && (
          <p>Print in progress: {progress.toFixed(1)}% complete</p>
        )}
        {printerStatus === 'completed' && (
          <p>Print completed successfully!</p>
        )}
      </div>
    </section>
  );
};

// Wrapper for testing
const TestWrapper = ({ children }: { children: React.ReactNode }) => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false }
    }
  });

  return (
    <MemoryRouter>
      <QueryClientProvider client={queryClient}>
        <SocketProvider enable={true}>
          {children}
        </SocketProvider>
      </QueryClientProvider>
    </MemoryRouter>
  );
};

describe('End-to-End User Workflow Integration Tests', () => {
  beforeEach(() => {
    // Reset store state
    mockStore = createMockStore();
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  describe('Complete 3D Printing Workflow', () => {
    it('executes full workflow: upload → queue → print → monitor → complete', async () => {
      const user = userEvent.setup();
      
      render(
        <TestWrapper>
          <PrintingApp />
        </TestWrapper>
      );

      // Step 1: Start in upload view
      expect(screen.getByRole('button', { name: 'File Upload', pressed: true })).toBeInTheDocument();
      expect(screen.getByText(/upload 3d models/i)).toBeInTheDocument();

      // Step 2: Upload a file
      const fileInput = screen.getByLabelText(/drop 3d model files/i);
      const mockFile = new File(['gcode content'], 'test-model.gcode', { type: 'text/plain' });
      
      await user.upload(fileInput, mockFile);

      await waitFor(() => {
        expect(screen.getByText('test-model.gcode')).toBeInTheDocument();
        expect(mockStore.addJob).toHaveBeenCalled();
      });

      // Step 3: Navigate to printer control
      await user.click(screen.getByRole('button', { name: 'Printer Control' }));

      await waitFor(() => {
        expect(screen.getByText(/printer control/i)).toBeInTheDocument();
      });

      // Step 4: Select job and start print
      const jobRadio = screen.getByRole('radio', { name: /test-model\.gcode.*queued/i });
      await user.click(jobRadio);

      const startButton = screen.getByRole('button', { name: 'Start Print' });
      expect(startButton).not.toBeDisabled();
      
      await user.click(startButton);

      await waitFor(() => {
        expect(mockApiCalls.startPrint).toHaveBeenCalledWith({ jobId: expect.any(String) });
        expect(screen.getByText(/printing/i)).toBeInTheDocument();
      });

      // Step 5: Navigate to live monitor
      await user.click(screen.getByRole('button', { name: 'Live Monitor' }));

      await waitFor(() => {
        expect(screen.getByText(/live monitor/i)).toBeInTheDocument();
      });

      // Step 6: Monitor progress and completion
      const progressBar = screen.getByRole('progressbar');
      expect(progressBar).toBeInTheDocument();
      expect(progressBar).toHaveAttribute('aria-valuenow');

      // Wait for some progress updates
      await waitFor(() => {
        const progress = parseFloat(progressBar.getAttribute('aria-valuenow') || '0');
        expect(progress).toBeGreaterThan(0);
      }, { timeout: 3000 });

      expect(screen.getByText(/print in progress/i)).toBeInTheDocument();
    }, 10000);

    it('handles error recovery during printing workflow', async () => {
      const user = userEvent.setup();
      
      render(
        <TestWrapper>
          <PrintingApp />
        </TestWrapper>
      );

      // Set up initial state with a print job
      mockStore.addJob({
        id: 'test-job-1',
        name: 'error-test.gcode',
        status: 'printing',
        progress: 50
      });
      mockStore.updatePrinterStatus('printing');

      // Navigate to control panel
      await user.click(screen.getByRole('button', { name: 'Printer Control' }));

      await waitFor(() => {
        expect(screen.getByText(/printing/i)).toBeInTheDocument();
      });

      // Simulate error by attempting emergency stop
      const stopButton = screen.getByRole('button', { name: 'Stop Print' });
      expect(stopButton).not.toBeDisabled();

      // Mock confirmation dialog
      window.confirm = vi.fn(() => true);
      await user.click(stopButton);

      await waitFor(() => {
        expect(mockApiCalls.stopPrint).toHaveBeenCalled();
        expect(screen.getByText(/idle/i)).toBeInTheDocument();
      });
    });

    it('supports concurrent operations and real-time updates', async () => {
      const user = userEvent.setup();
      
      render(
        <TestWrapper>
          <PrintingApp />
        </TestWrapper>
      );

      // Set up printing state
      mockStore.addJob({
        id: 'concurrent-job',
        name: 'concurrent-test.gcode',
        status: 'printing',
        progress: 25
      });
      mockStore.updatePrinterStatus('printing');

      // Navigate to monitor view
      await user.click(screen.getByRole('button', { name: 'Live Monitor' }));

      // Simulate real-time temperature updates via WebSocket
      act(() => {
        mockSocket.emit('temperature-update', { hotend: 205, bed: 62 });
      });

      await waitFor(() => {
        expect(screen.getByText(/205/)).toBeInTheDocument();
        expect(screen.getByText(/62/)).toBeInTheDocument();
      });

      // Switch to control panel while monitoring
      await user.click(screen.getByRole('button', { name: 'Printer Control' }));

      // Should still show current print status
      expect(screen.getByText(/printing/i)).toBeInTheDocument();

      // Pause the print
      const pauseButton = screen.getByRole('button', { name: 'Pause' });
      await user.click(pauseButton);

      await waitFor(() => {
        expect(mockApiCalls.pausePrint).toHaveBeenCalled();
      });
    });
  });

  describe('Project Integration', () => {
    it('integrates projects with printing workflow', async () => {
      const user = userEvent.setup();
      
      render(
        <TestWrapper>
          <PrintingApp />
        </TestWrapper>
      );

      // Navigate to projects
      await user.click(screen.getByRole('button', { name: 'Projects' }));

      expect(screen.getByText(/projects/i)).toBeInTheDocument();

      // Create new project
      window.prompt = vi.fn(() => 'Test 3D Print Project');
      await user.click(screen.getByRole('button', { name: 'Create New Project' }));

      await waitFor(() => {
        expect(mockApiCalls.createProject).toHaveBeenCalledWith({
          name: 'Test 3D Print Project'
        });
      });

      // Add files to project workflow
      await user.click(screen.getByRole('button', { name: 'File Upload' }));

      const fileInput = screen.getByLabelText(/drop 3d model files/i);
      const projectFile = new File(['project content'], 'project-model.stl', { 
        type: 'application/octet-stream' 
      });
      
      await user.upload(fileInput, projectFile);

      await waitFor(() => {
        expect(screen.getByText('project-model.stl')).toBeInTheDocument();
      });

      // Files should now be available for printing
      await user.click(screen.getByRole('button', { name: 'Printer Control' }));

      expect(screen.getByText(/project-model\.stl/)).toBeInTheDocument();
    });

    it('handles collaborative project updates via WebSocket', async () => {
      const user = userEvent.setup();
      
      // Set up initial project
      mockStore.setState({
        projects: [{
          id: 'collab-project',
          name: 'Collaborative Print',
          tasks: [{ id: 'task-1', name: 'Design review', status: 'todo' }]
        }]
      });

      render(
        <TestWrapper>
          <PrintingApp />
        </TestWrapper>
      );

      await user.click(screen.getByRole('button', { name: 'Projects' }));

      // Select project
      const projectCard = screen.getByRole('button', { name: /collaborative print/i });
      await user.click(projectCard);

      expect(projectCard).toHaveAttribute('aria-pressed', 'true');

      // Simulate real-time project update from another user
      act(() => {
        mockSocket.emit('project-updated', {
          projectId: 'collab-project',
          update: {
            tasks: [
              { id: 'task-1', name: 'Design review', status: 'completed' },
              { id: 'task-2', name: 'Print preparation', status: 'todo' }
            ]
          }
        });
      });

      // Project should reflect real-time changes
      // (This would need to be implemented in the actual socket provider)
    });
  });

  describe('Performance Under Load', () => {
    it('maintains responsiveness during high-frequency updates', async () => {
      const user = userEvent.setup();
      
      render(
        <TestWrapper>
          <PrintingApp />
        </TestWrapper>
      );

      // Set up monitoring view with active print
      mockStore.updatePrinterStatus('printing');
      await user.click(screen.getByRole('button', { name: 'Live Monitor' }));

      const startTime = performance.now();

      // Simulate many rapid updates
      for (let i = 0; i < 100; i++) {
        act(() => {
          mockSocket.emit('temperature-update', {
            hotend: 200 + Math.random() * 20,
            bed: 60 + Math.random() * 10
          });
        });
      }

      const endTime = performance.now();
      
      // Should handle updates efficiently
      expect(endTime - startTime).toBeLessThan(1000);

      // UI should remain responsive
      const controlButton = screen.getByRole('button', { name: 'Printer Control' });
      await user.click(controlButton);

      expect(screen.getByText(/printer control/i)).toBeInTheDocument();
    });

    it('handles memory efficiently during long printing sessions', async () => {
      const user = userEvent.setup();
      
      render(
        <TestWrapper>
          <PrintingApp />
        </TestWrapper>
      );

      mockStore.updatePrinterStatus('printing');
      await user.click(screen.getByRole('button', { name: 'Live Monitor' }));

      // Simulate 1 hour of updates (every 2 seconds = 1800 updates)
      const updateCount = 100; // Reduced for test performance
      
      for (let i = 0; i < updateCount; i++) {
        act(() => {
          mockSocket.emit('progress-update', { progress: i / updateCount * 100 });
          mockSocket.emit('temperature-update', {
            hotend: 200 + (i % 20),
            bed: 60 + (i % 10)
          });
        });
      }

      // Should still be responsive after many updates
      const uploadButton = screen.getByRole('button', { name: 'File Upload' });
      await user.click(uploadButton);

      expect(screen.getByText(/upload 3d models/i)).toBeInTheDocument();
    });
  });

  describe('Accessibility Throughout Workflows', () => {
    it('maintains keyboard navigation across all views', async () => {
      const user = userEvent.setup();
      
      render(
        <TestWrapper>
          <PrintingApp />
        </TestWrapper>
      );

      // Test navigation between views using keyboard
      const navButtons = [
        screen.getByRole('button', { name: 'File Upload' }),
        screen.getByRole('button', { name: 'Projects' }),
        screen.getByRole('button', { name: 'Printer Control' }),
        screen.getByRole('button', { name: 'Live Monitor' })
      ];

      for (const button of navButtons) {
        button.focus();
        expect(button).toHaveFocus();
        
        await user.keyboard('{Enter}');
        await waitFor(() => {
          expect(button).toHaveAttribute('aria-pressed', 'true');
        });
      }
    });

    it('provides appropriate ARIA live regions for status updates', async () => {
      render(
        <TestWrapper>
          <PrintingApp />
        </TestWrapper>
      );

      // Navigate to monitor view
      const user = userEvent.setup();
      await user.click(screen.getByRole('button', { name: 'Live Monitor' }));

      // Should have live regions for status updates
      const logRegion = screen.getByRole('log');
      expect(logRegion).toHaveAttribute('aria-live', 'polite');

      mockStore.updatePrinterStatus('printing');

      await waitFor(() => {
        expect(logRegion).toHaveTextContent(/print in progress/i);
      });
    });
  });
});